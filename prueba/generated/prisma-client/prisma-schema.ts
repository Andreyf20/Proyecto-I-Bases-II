// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateProducto {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createProducto(data: ProductoCreateInput!): Producto!
  updateProducto(data: ProductoUpdateInput!, where: ProductoWhereUniqueInput!): Producto
  updateManyProductoes(data: ProductoUpdateManyMutationInput!, where: ProductoWhereInput): BatchPayload!
  upsertProducto(where: ProductoWhereUniqueInput!, create: ProductoCreateInput!, update: ProductoUpdateInput!): Producto!
  deleteProducto(where: ProductoWhereUniqueInput!): Producto
  deleteManyProductoes(where: ProductoWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Producto {
  _id: ID!
  cantidad: Float
  codigo: Float
  enabled: Float
  nombre: String
  precio: Float
  provincia: Float
}

type ProductoConnection {
  pageInfo: PageInfo!
  edges: [ProductoEdge]!
  aggregate: AggregateProducto!
}

input ProductoCreateInput {
  _id: ID
  cantidad: Float
  codigo: Float
  enabled: Float
  nombre: String
  precio: Float
  provincia: Float
}

type ProductoEdge {
  node: Producto!
  cursor: String!
}

enum ProductoOrderByInput {
  _id_ASC
  _id_DESC
  cantidad_ASC
  cantidad_DESC
  codigo_ASC
  codigo_DESC
  enabled_ASC
  enabled_DESC
  nombre_ASC
  nombre_DESC
  precio_ASC
  precio_DESC
  provincia_ASC
  provincia_DESC
}

type ProductoPreviousValues {
  _id: ID!
  cantidad: Float
  codigo: Float
  enabled: Float
  nombre: String
  precio: Float
  provincia: Float
}

type ProductoSubscriptionPayload {
  mutation: MutationType!
  node: Producto
  updatedFields: [String!]
  previousValues: ProductoPreviousValues
}

input ProductoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductoWhereInput
  AND: [ProductoSubscriptionWhereInput!]
}

input ProductoUpdateInput {
  cantidad: Float
  codigo: Float
  enabled: Float
  nombre: String
  precio: Float
  provincia: Float
}

input ProductoUpdateManyMutationInput {
  cantidad: Float
  codigo: Float
  enabled: Float
  nombre: String
  precio: Float
  provincia: Float
}

input ProductoWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  cantidad: Float
  cantidad_not: Float
  cantidad_in: [Float!]
  cantidad_not_in: [Float!]
  cantidad_lt: Float
  cantidad_lte: Float
  cantidad_gt: Float
  cantidad_gte: Float
  codigo: Float
  codigo_not: Float
  codigo_in: [Float!]
  codigo_not_in: [Float!]
  codigo_lt: Float
  codigo_lte: Float
  codigo_gt: Float
  codigo_gte: Float
  enabled: Float
  enabled_not: Float
  enabled_in: [Float!]
  enabled_not_in: [Float!]
  enabled_lt: Float
  enabled_lte: Float
  enabled_gt: Float
  enabled_gte: Float
  nombre: String
  nombre_not: String
  nombre_in: [String!]
  nombre_not_in: [String!]
  nombre_lt: String
  nombre_lte: String
  nombre_gt: String
  nombre_gte: String
  nombre_contains: String
  nombre_not_contains: String
  nombre_starts_with: String
  nombre_not_starts_with: String
  nombre_ends_with: String
  nombre_not_ends_with: String
  precio: Float
  precio_not: Float
  precio_in: [Float!]
  precio_not_in: [Float!]
  precio_lt: Float
  precio_lte: Float
  precio_gt: Float
  precio_gte: Float
  provincia: Float
  provincia_not: Float
  provincia_in: [Float!]
  provincia_not_in: [Float!]
  provincia_lt: Float
  provincia_lte: Float
  provincia_gt: Float
  provincia_gte: Float
  AND: [ProductoWhereInput!]
}

input ProductoWhereUniqueInput {
  _id: ID
}

type Query {
  producto(where: ProductoWhereUniqueInput!): Producto
  productoes(where: ProductoWhereInput, orderBy: ProductoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Producto]!
  productoesConnection(where: ProductoWhereInput, orderBy: ProductoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductoConnection!
  node(id: ID!): Node
}

type Subscription {
  producto(where: ProductoSubscriptionWhereInput): ProductoSubscriptionPayload
}
`